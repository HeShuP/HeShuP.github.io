opengauss的double write，打开文件时，使用的 static const int DW_FILE_FLAG = (O_RDWR | O_SYNC | O_DIRECT | PG_BINARY);

mysql采用双写机制，解决页折断的问题；

opengauss的双写和增量checkpoint，是一起使用的，因为增量checkpoint，触发的频率更高，一分钟一次，更容易导致xlog文件膨胀；

而postgresql，使用全量checkpoint，触发频率不高，xlog膨胀不明显；

双写的关键设计：

- 引入双写文件，每次页面下盘前，先写双写文件，双写文件下盘后，再写数据文件；
- 双写文件时可以复用的；

双写分批量下盘和单页面下盘；

找准目标，自己想成为什么样的人？

最不足的点，有明确的解决方案？

1、为什么在pg14中，Change checkpoint_completion_target default to 0.9？
答：
原因是开发者建议分散checkpoint执行时的IO，将checkpoint_completion_target调大，写脏的时间会更多，
达到降低ckpt期间磁盘IO的问题；
参考这个提交：
https://github.com/postgres/postgres/commit/bbcc4eb2e08fb6e4535c7f84b2c00f3ad508bb9b

2、pg为什么移除了ControlFileData中的prechekpoint？
答：
pg早期版本保留2个checkpoint，目的是当最新的一个ckpt记录如果损坏了，还可以用前一个ckpt来进行恢复。
移除prechekpoint有2个原因：
一个原因是：prevCheckPoint使用概率低。wal文件中，最新的一个ckpt记录损坏，而前一个ckpt记录没有损坏，这种场景出现的概率很小。更多的场景是要么都损坏了，要么都没损坏。
还有另一个原因是：为了节省磁盘空间；
所以在pg11中，移除了pg_control中的prevCheckPoint。
参考提交：https://github.com/postgres/postgres/commit/4b0d28de06b28e57c540fca458e4853854fbeaf8
讨论记录在这里：https://www.postgresql.org/message-id/20171107180116.s7xhcqeel45buiq4%40alap3.anarazel.de

pg_waldump:

#0  XLogReaderValidatePageHeader (state=0x6401e0, recptr=1275068416, phdr=0x640b00 "\001\321\a") at xlogreader.c:775
#1  0x000000000040574a in ReadPageInternal (state=0x6401e0, pageptr=1275068416, reqLen=0) at xlogreader.c:629
#2  0x00000000004060d9 in XLogFindNextRecord (state=0x6401e0, RecPtr=1275068416) at xlogreader.c:959
#3  0x00000000004044a7 in main (argc=2, argv=0x7fffffffe3e8) at pg_waldump.c:1116

/*                                                                                                                                                                        │   │857              * Check that the address on the page agrees with what we expected. This                                                                                                  │   │858              * check typically fails when an old WAL segment is recycled, and hasn't                                                                                                  │   │859              * yet been overwritten with new data yet.                                                                                                                                │   │860              */                                                                                                                                                                       │   │861             if (hdr->xlp_pageaddr != recaddr)                                                                                                                                         │   │862             {                                                                                                                                                                         │   │863                     char            fname[MAXFNAMELEN];                                                                                                                               │   │864                                                                                                                                                                                       │  >│865                     XLogFileName(fname, state->readPageTLI, segno, state->wal_segment_size);                                                                                          │   │866                                                                                                                                                                                       │   │867                     report_invalid_record(state,                                                                                                                                      │   │868                                                               "unexpected pageaddr %X/%X in log segment %s, offset %u",                                                               │   │869                                                               (uint32) (hdr->xlp_pageaddr >> 32), (uint32) hdr->xlp_pageaddr,                                                         │   │870                                                               fname,                                                                                                                  │   │871                                                               offset);                                                                                                                │   │872                     return false;                                                                                                                                                     │   │873             }                

postgres=# create table tb_1(id int,age int);

insert into tb_1(id,age) values(1, generate_series(0,1000));

create table tb_2(id int,name text,age int);

insert into tb_2(id,name,age) values(generate_series(0,100000), substr(md5(random()::text),0,25),generate_series(0,100000));

CREATE TABLE
postgres=# insert into tb_1(id,age) values(1, generate_series(0,1000));